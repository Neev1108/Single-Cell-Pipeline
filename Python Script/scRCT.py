# -*- coding: utf-8 -*-
"""scRNAseq Tutorial Neuron Dataset.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1Ir3kLJnSJcWnXfZZZ6qX4oIDIbU6IZ79
"""

"""Helper Functions
Created helper functionss to minimize padding from log related code within the pipeline."""
#Flush file on write in case of forced program exit
def log(msg):
    file.write(msg+"\n")
    file.flush()

#Save figure and V&V
def save_figure(image_name, dir):
    plt.savefig(dir + image_name)
    if interrupt: plt.show()
    VV_file_save(dir,image_name,"Saved \"" + image_name + "\"")
    plt.close()


#Validate and verify flies were successfully saved
def VV_file_save(dir, filename, success_msg):
    if not os.path.isfile(dir + filename):
        print("ERROR: Could not save \""+filename+"\" file!")
        log("ERROR: Could not save \""+filename+"\" file!")
    else:
        log(success_msg)

#Validate and Verify: Marker gene file format
def VV_markers(ref):
    for col in ref.columns:
        if "Unnamed" in col:
            return False
    return True

#Plot UMAP or tSNE
def plot(adata, color, title=""):
    if tsne:
        if title == "":
            sc.pl.tsne(adata, color=color, show=False)
        else:
            sc.pl.tsne(adata, color=color, title=title, show=False)
    else:
        if title == "":
            sc.pl.umap(adata, color=color, show=False)
        else:
            sc.pl.umap(adata, color=color, title=title, show=False)

def plot_annotation(adata, color, title):
    sc.set_figure_params(figsize=(10, 10))
    if tsne:
        sc.pl.tsne(adata, color=color, title=title, legend_loc='on data', show=False)
    else:
        sc.pl.umap(adata, color=color, title=title, legend_loc='on data', show=False)

#Normalize adata, while also validating and verify its success
def normalize_and_VV():
    adata.write("pre-normalize.h5ad")
    sc.pp.normalize_total(adata, target_sum=1e6)    #Pipeline normalization
    adata.write("post-normalize.h5ad")
    pre_hash = hashlib.md5(open("pre-normalize.h5ad", "rb").read()).hexdigest()
    post_hash = hashlib.md5(open("post-normalize.h5ad", "rb").read()).hexdigest()
    os.remove("pre-normalize.h5ad")                 #Remove files for discretion
    os.remove("post-normalize.h5ad")
    assert not pre_hash == post_hash, "Could not normalize data! Try reinstalling scanpy."

#Validate and Verify: Count amount of NA's that were generated in the classification output. Warn if there are too many NA's.
def VnV_classification():
    count = 0
    for classification in adata.obs['cell_type']:
        if classification.lower() == "na" or pd.isnull(classification):
            count+=1
    if count > 0:
        print(str(count)+"/"+str(adata.n_obs)+" cells were not able to be classified. Try adjusting the parameters.")
    else:
        print("All cells were classified!")

    assert not count == adata.n_obs, "None of the cells were able to be classified! Try using a different marker gene file."
    if (count/adata.n_obs) > annotate_limit:
        print("WARNING: More than " + str(annotate_limit * 100) + "% of cells were NOT able to be classified!")

"""Setup Log File
Log major outputs and actions for validation and verification of a successfully run program.
Created helper functionss to minimize padding from log related code within the pipeline."""
import os
import traceback

#Directories
log_dir = "../../02-Scanpy/VV_logs/"
image_directory = "../../02-Scanpy/Images/"
marker_dir = "../../03-ScoreCT/Marker_genes/"
adata_dir = "../../02-Scanpy/Adata/"
annotation_dir = "../../03-ScoreCT/Annotation_Exports/"
annotate_py_dir = "../03-ScoreCT/"
final_plot_dir = "../../03-ScoreCT/tSNE_UMAP/"

#V&V existance of directories
assert os.path.exists(log_dir), log_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."
assert os.path.exists(image_directory), image_directory+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."
assert os.path.exists(marker_dir), marker_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."
assert os.path.exists(adata_dir), adata_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current direcotry."
assert os.path.exists(annotation_dir), annotation_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."
assert os.path.exists(annotate_py_dir), annotate_py_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."
assert os.path.exists(final_plot_dir), final_plot_dir+" not found. Please run \'scRNAseq_mkdir.sh\' in the current directory."

#Log File
run_num = 1
while os.path.exists(log_dir+"run"+str(run_num)+".txt"):
    run_num += 1
file = open(log_dir+"run"+str(run_num)+".txt", "w")
print("Created log file \"run"+str(run_num)+".txt\" in "+log_dir)

"""***Pipline starts here***
Try-catch statement used to log exceptions."""
try:
    """Import or Install Libraries"""
    try:
        print("Loading packages...")
        log("Program started")
        import sys
        import subprocess
        import gzip
        import hashlib

        import numpy as np
        import pandas as pd
        import scanpy as sc
        import seaborn as sb
        import matplotlib.pyplot as plt
        import scorect_api as ct
        import openpyxl
    except:
        print("***Some packages have not been installed. Installing now...***")
        log("Some packages have not been installed. Attempting to install...")

        # Retrieve installer if not available
        import urllib.request
        remove = False
        if not os.path.exists("get-pip.py"):
            urllib.request.urlretrieve("https://bootstrap.pypa.io/get-pip.py", "get-pip.py")
            remove = True
        subprocess.check_call([sys.executable, "get-pip.py"])

        # Download and install packages if not installed
        subprocess.check_call([sys.executable, "-m", "pip", "install", "numpy"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pandas"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "seaborn"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "scanpy"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "matplotlib"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "openpyxl"])

        if not os.path.exists("scorect_api.py"):
            urllib.request.urlretrieve("https://raw.githubusercontent.com/LucasESBS/scoreCT/master/src/scorect_api.py", "scorect_api.py")
            # Required by scorect_api
            subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])

        # Packages used but not included in scanpy package
        subprocess.check_call([sys.executable, "-m", "pip", "install", "harmonypy"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "scikit-misc"])
        subprocess.check_call([sys.executable, "-m", "pip", "install", "leidenalg"])

        # Remove installer if it wasn't available before for discretion
        if remove: os.remove("get-pip.py")
        log("Succesfully installed packages")

        #Try importing packages again. If fail, proceed with normal crash protocol
        print("Attempting to loading packages again. If failed to load, please install the package on your own or re-run program.")
        import sys
        import subprocess
        import gzip
        import hashlib

        import numpy as np
        import pandas as pd
        import scanpy as sc
        import seaborn as sb
        import matplotlib.pyplot as plt
        import scorect_api as ct
        import openpyxl
    print("Package import success!")
    log("Successfully loaded packages")

    """Variables
    These will be default numbers if the user does not change these inputs. Much of these are variable throughout experiments so the defaults will be basic at best.
    """
    #These arguments will be dependent on user input.
    #User will check visualizations and other experiment variables to decide input to optimize the experiment to their needs.
    n=15
    cluster_res = 0.5
    min_cells = -1
    min_genes = -1
    tsne = False
    genes = []

    #Annotation arguments
    species = ""
    tissue = "tissue"
    K = 300
    m = 15

    #Other arguments
    file_path = ""
    markers_path = ""
    interrupt=True

    """V&V threshold"""
    filter_limit = 0.3
    highly_var_limit = 0.2
    annotate_limit = 0.3

    """Command line argument syntax"""
    #Scanpy
    n_arg = "--neighbors"
    resoution_arg = "--res"
    cell_arg = "--min_cells"
    gene_arg = "--min_genes"
    display_arg = "--genes"
    plot_arg = "--plot"

    #Annotation
    species_arg = "--species"
    tissie_arg = "--tissue"
    K_arg = "--K"
    m_arg = "--bins"

    #Other
    file_path_arg = "--filepath"
    markers_path_arg = "--markers"
    disable_interrupt_arg = "-disable_interrupts"

    """Parse arguments"""
    args = sys.argv[1:]
    for arg in args:
        #Required
        if file_path_arg in arg:
            file_path = arg[arg.index("=") + 1:]
            if file_path[-1] != "/" or file_path[-1] != "\\": file_path += "/"

        #ScanPy arguments
        elif n_arg+"=" in arg:
            n = int(arg[arg.index("=") + 1:])
        elif resoution_arg+"=" in arg:
            cluster_res = float(arg[arg.index("=") + 1:])
        elif cell_arg+"=" in arg:
            min_cells = float(arg[arg.index("=") + 1:])
        elif gene_arg+"=" in arg:
            min_genes = float(arg[arg.index("=") + 1:])
        elif display_arg+"=" in arg:                 #Genes listed must be comma separated
            genes = arg[arg.index("=") + 1:].split(",")
        elif plot_arg+"=" in arg:
            plot_input = arg[arg.index("=")+1:].lower()
            if plot_input == "tsne" or plot_input == "t-sne": tsne = True

        #Annotation
        elif species_arg+"=" in arg:
            species = arg[arg.index("=") + 1:]
        elif tissie_arg+"=" in arg:
            tissue = arg[arg.index("=") + 1:]
        elif K_arg+"=" in arg:
            K = float(arg[arg.index("=") + 1:])
        elif m_arg+"=" in arg:
            m = float(arg[arg.index("=") + 1:])
        elif markers_path_arg in arg:
            markers_path = arg[arg.index("=") + 1:]

        #Other
        elif disable_interrupt_arg in arg:
            interrupt = False
        else:
            sys.exit(arg+" is not a valid argument!")
    log("Successfully parsed command arguments")

    #Log parameters
    min_genes_log = min_genes
    min_cells_log = min_cells
    plot_log = "umap"
    if min_genes == -1: min_genes_log = "default"
    if min_cells == -1: min_cells_log = "default"
    if tsne: plot_log = "tsne"

    log("\n***Parameters***\n"
        "file path: "+file_path+"\n"
        "marker gene file: "+markers_path+"\n"+
        "species: "+species+"\n"
        "tissue: "+tissue+"\n"
        "min genes: "+str(min_genes_log)+"\n"
        "min cells: "+str(min_cells_log)+"\n"
        "knn k: "+str(n)+"\n"
        "cluster resolution: "+str(cluster_res)+"\n"
        "scorect K: "+str(K)+"\n"
        "scorect m: "+str(m)+"\n"
        "plot: "+plot_log+"\n"
        "display genes: "+str(genes)+"\n"
        "interrupt: "+str(interrupt)+"\n"
        "****************\n")

    output_name = species
    if not tissue == "\"\"":
        output_name += "_"+tissue

    # Set up Image Directory
    image_directory = image_directory + "run" + str(run_num) + "_"+output_name + "/"
    os.mkdir(image_directory)
    print("Images will be automatically saved at \"" + image_directory + "\"")
    log("Set up  \"run" + str(run_num) + "_"+output_name + "/\" directory in " + image_directory)

    # Set up Final Plot Directory
    final_plot_dir = final_plot_dir + "run" + str(run_num) + "_"+output_name + "/"
    os.mkdir(final_plot_dir)
    print("Anntation plot will be automatically saved at \"" + final_plot_dir + "\"")
    log("Set up \"run" + str(run_num) + "_"+output_name+"/\" directory" + final_plot_dir)

    """Load data"""
    if file_path == "":             #File path is required!
        raise FileExistsError("You must input a file path of the cell ranger output!")

    #If filepath points directly to data or to cellranger output
    print("Locating cellranger output...")
    if os.path.isfile(file_path+"matrix.mtx.gz") and os.path.isfile(file_path+"features.tsv.gz") and os.path.isfile(file_path+"barcodes.tsv.gz"):
        pass
    else:
        if "/outs" in file_path:                                                                         #File path points to other paths within cellranger output
            file_path = file_path[:file_path.index("outs")]
        if not os.path.exists(file_path+"outs/filtered_feature_bc_matrix/"):                             #Corrupted cellranger output (that isn't pointed to data)
            raise FileExistsError(file_path+"outs/filtered_feature_bc_matrix/ is missing in cell ranger output!")
        if not (os.path.isfile(file_path+"outs/filtered_feature_bc_matrix/matrix.mtx.gz") and os.path.isfile(file_path+"outs/filtered_feature_bc_matrix/features.tsv.gz") and os.path.isfile(file_path+"outs/filtered_feature_bc_matrix/barcodes.tsv.gz")):
            raise FileNotFoundError("One or more of the following files in "+file_path+"outs/filtered_feature_bc_matrix/ is missing: matrix.mtx.gz, features.tsv.gz, barcodes.tsv.gz")   #Missing files in filepath
        file_path += "outs/filtered_feature_bc_matrix/"

    #V&V:
    ##V&V matrix.mtx format
    with gzip.open(file_path+'matrix.mtx.gz', 'rb') as mtx:
        for i in range(5000):
            line = mtx.readline().decode("utf-8")
            while line[0] == '%': line = mtx.readline().decode("utf-8")  # Skip header(s)
            entry = line.split(" ")
            assert len(entry) == 3, "matrix.mtx is NOT in the correct format: "+line
            try:
                assert int(entry[2]) == float(entry[2]), "Please convert matrix.mtx to contain integer values: "+line
            except ValueError:
                assert False, "matrix.mtx is NOT in the correct format: "+line
    ##V&V barcodes.tsv/sequences are in the correct format
    with gzip.open(file_path+'barcodes.tsv.gz', 'rb') as barcodes:
        for i in range(1000):
            try:
                entry = barcodes.readline().decode("utf-8")
                assert entry[:-3].isalpha() and entry[-3:] == "-1\n", "Entries in barcodes.tsv are NOT in the correct format: "+entry
            except IndexError:
                break
    print("Loading data at " + file_path + "...")
    log("Cellranger output verified")

    #Load cellranger data
    adata = sc.read_10x_mtx(file_path)
    log("Loaded cellranger output")

    """Overview Data"""
    print("Number of cells: "+str(adata.n_obs))
    print("Number of genes: "+str(adata.n_vars))

    #Display a graph for the highest expressed genes
    """
    In our test, MT genes seem to be highly expressed, and thus will be a cause of concern for our experiment. 
    In standard sCRNA-seq experiments, the common thought is to remove MT genes as a sign of low quality cells due to cell perforation of cytoplasmic RNA loss. 
    However for NASA's Genelab, spaceflight seems to affect mitochondrial gene function, according to our Genelab researcher Dr. Afshin Beheshti.
    Therefore we have made the decision to not remove mitochondrial reads because that would filter our goal of analyzing biological processes from spaceflight.
    
    **Inclusion of mitochondrial reads is vital as spaceflight has demonstrated its involvement in the following:**
    - innate immunity 
    - lipid metabolism
      => can contribute to greater risk of cardiovascular issues
    - gene regulation 
    - ETC, ATP synthesis (from increased radiation)
      - increased levels of oxidative damage and stress
      - muscle loss from metabolic flux changes 
    """
    sc.pl.highest_expr_genes(adata,show=False)
    save_figure("highly_expressed_genes.png", image_directory)

    """Quality Control"""
    #Basic Filtering
    """
    Our first important step in our analysis will be to do some quality control. Our 2 most important steps of quality control are:
    - Basic filtering 
    - Removal of highly expressed genes
    
    In a standard scRNAseq experiment, there will be 3 steps, including removing MT reads. 
    But of course, of spaceflight experiments, we at Genelab have decided to not include this step in our analysis.
    """

    #Calculate QC metrics and collect dataframe results for cell and gene
    stats = sc.pp.calculate_qc_metrics(adata)
    cell_qc_dataframe = stats[0]
    gene_qc_dataframe = stats[1]

    ##Graph quality control graphs to find thresholds.

    #Helper class that follows cursor and displays a vertical red line when viewing plot to help determine a threshold.
    #This is implementation is a modified version of Matplotlib's open source code: https://matplotlib.org/stable/gallery/misc/cursor_demo.html
    class VerticalCursor:
        #crosshair cursor.
        def __init__(self, ax, x_name):
            self.ax = ax
            self.vertical_line = ax.axvline(color='red', lw=0.8)
            # text location in axes coordinates
            self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)
            self.x_name = x_name

        def set_cross_hair_visible(self, visible):
            need_redraw = self.vertical_line.get_visible() != visible
            self.vertical_line.set_visible(visible)
            self.text.set_visible(visible)
            return need_redraw

        def on_mouse_move(self, event):
            if not event.inaxes:
                need_redraw = self.set_cross_hair_visible(False)
                if need_redraw:
                    self.ax.figure.canvas.draw()
            else:
                self.set_cross_hair_visible(True)
                x, y = event.xdata, event.ydata
                # update the line position
                self.vertical_line.set_xdata(x)
                self.text.set_text(self.x_name+'=%1.2f' % x)
                self.ax.figure.canvas.draw()

    """Plot cell and gene distribution
    Looking at this graph, users must decide where to do the minimum cutoff for minimum genes. 
    It is necessary to filter cells based on minimum genes because with that threshold, we can filter cells that have may have been contaminated.
    It is important to do gene filtering after cell filtering because some genes may be detected only in low quality cells.
    Users can zoom into graph by clicking onto the magnifying glass and drawing a rectangle where they wish to have a closer look. 
    """

    #Cell distribution

    fig, ax = plt.subplots()
    cursor = VerticalCursor(ax, "min_genes")
    fig.canvas.mpl_connect('motion_notify_event', cursor.on_mouse_move)

    plt.hist(cell_qc_dataframe['n_genes_by_counts'], bins="sqrt")
    plt.xlabel('N genes')
    plt.ylabel('N cells')
    plt.title("Use the graph to determine a threshold for filtering the dataset.")
    save_figure("gene_distribution.png", image_directory)

    ##Collect user input for the minimum amount of genes to filter cells. Can be left blank if arguments already given or for default parameters.
    while interrupt:
      try:
        min_gene_text = min_genes
        if min_gene_text == -1:
            min_gene_text = "default settings"
        g_value = input("Input min_genes threshold or leave blank to use \'"+str(min_gene_text)+"\': ")
        if g_value == "": break
        min_genes = int(g_value)
        break
      except:
        print("\nError: Please enter an integer value or leave blank!")

    #Gene distribution=
    fig, ax = plt.subplots()
    cursor = VerticalCursor(ax, "min_cells")
    fig.canvas.mpl_connect('motion_notify_event', cursor.on_mouse_move)

    plt.hist(gene_qc_dataframe['n_cells_by_counts'], bins="sqrt")
    plt.xlabel('N cells expressing > 0')
    plt.ylabel('log(N genes)')
    plt.yscale('log')
    plt.title("Use the graph to determine a threshold for filtering the dataset.")
    save_figure("cell_distribution.png", image_directory)

    ##Collect user input for the minimum amount of cells to filter genes. Can be left blank if arguments already given or for default parameters.
    while interrupt:
      try:
        min_cell_text = min_cells
        if min_cell_text == -1:
            min_cell_text = "default settings"
        c_value = input("Input min_cells threshold or leave blank to use \'"+str(min_cell_text)+"\': ")
        if c_value == "": break
        min_cells = int(c_value)
        break
      except:
        print("\nError: Please enter an integer value or leave blank!")

    """Filtering
    For our defaults, the minimum number of genes for filtering cells is a set number of 1.
    The minimum number of cells for filtering genes is instead going to be percentile based.
    """
    unfiltered_genes = adata.var_names
    cell_filter_percentile = 0.01

    prefiltered_gene_length = adata.n_vars
    prefiltered_cell_length = adata.n_obs

    if min_cells == -1:
      print("Filtering genes using default settings.")
      log("Filtering genes using default settings")
      min_cells = 1
    sc.pp.filter_genes(adata, min_cells=min_cells)

    if min_genes == -1:             #Percentile-based filtering (default)
      print("Filtering cells using default settings.")
      log("Filtering cells using default settings")
      stats = sc.pp.calculate_qc_metrics(adata)
      gene_counts_mean = len(stats[0]['n_genes_by_counts'])
      min_genes = round(gene_counts_mean*cell_filter_percentile)
    sc.pp.filter_cells(adata, min_genes=min_genes)

    print("Filtered using min_genes="+str(int(min_genes))+" and min_cells="+str(int(min_cells))+".")
    log("Filtered using min_genes=" + str(int(min_genes)) + " and min_cells=" + str(int(min_cells)))

    #Display filtering results
    print(str(prefiltered_gene_length-adata.n_vars)+"/"+str(prefiltered_gene_length)+" genes filtered")
    print(str(prefiltered_cell_length - adata.n_obs) + "/" + str(prefiltered_cell_length) + " cells filtered")
    log(str(prefiltered_gene_length-adata.n_vars)+"/"+str(prefiltered_gene_length)+" genes filtered out")
    log(str(prefiltered_cell_length - adata.n_obs) + "/" + str(prefiltered_cell_length) + " cells filtered out")

    #V&V
    assert adata.n_vars > 0, "All genes have been filtered out!"
    assert adata.n_obs > 0, "All cells have been filtered out!"

    if (prefiltered_gene_length-adata.n_vars)/prefiltered_gene_length > filter_limit:
        print("WARNING: More than "+str(filter_limit*100)+"% of genes have been filtered out!")
        log("WARNING: More than "+str(filter_limit*100)+"% of genes have been filtered out!")

    if (prefiltered_cell_length-adata.n_obs)/prefiltered_cell_length > filter_limit:
        print("WARNING: More than "+str(filter_limit*100)+"% of cells have been filtered out!")
        log("WARNING: More than "+str(filter_limit*100)+"% of cells have been filtered out!")


    """Normalize and Logarithmize Data
    Normalization will help to preserve biological heterogeneity without the influence of any technical noise like sequencing depth and gene abundance.
    Note: target_sum = 1e6 here refers to counts per million. 
    Although different methods of normalization does exist, that are more accurate and have better performance, the CPM method is more flexible and 
    scalable to all datasets and pipelines making it the best choice for our Genelab pipeline.
    
    sc.pp.log1p helps to logarithmize the data to improve data "symmetry" on a linear scale for more relevant and accurate data. 
    For further information on this topic, feel free to check out the following link: https://blog.qbaseplus.com/seven-tips-for-bio-statistical-analysis-of-gene-expression-data
    """
    normalize_and_VV()

    sc.pp.log1p(adata)
    #V&V
    assert 'log1p' in adata.uns.keys(), "Could not logarthimize data (required for clustering). Try reinstalling scanpy."

    print("Data normalized and logarithmized.")
    log("Data normalized and logarithmized")

    """Remove highly variable genes
    Determine and remove highly variable genes based on each genes' mean and variance. Removing these genes eliminates noise due to high variability in the data.
    
    Algorithm Description: Each gene is put into 20 'bins' based and their mean and variance. Each gene is then normalized based on the other genes in their bin. 
    If a gene's normalized dispersion is greater or equal to a z-score of 2 (~98th percentile) AND the gene has a low mean cell count, it is marked highly variable.
    (Decribed in the 'Identification of highly variable genes.' section of https://www.nature.com/articles/nbt.3192)
    """
    sc.pp.highly_variable_genes(adata, flavor='seurat', min_disp=2)
    print(str(len(adata.var[adata.var['highly_variable']==True]))+"/"+str(adata.n_vars)+" genes are highly variable and removed.")
    log(str(len(adata.var[adata.var['highly_variable'] == True])) + "/" + str(adata.n_vars) + " genes are highly variable and removed.")

    # V&V
    assert adata.n_vars > 0, "All genes have been filtered out!"    #Shouldn't be possible, but just in case
    if len(adata.var[adata.var['highly_variable'] == True])/adata.n_vars > highly_var_limit:
        print("WARNING: More than " + str(highly_var_limit * 100) + "% of genes have been filtered out due to high variability!")
        log("WARNING: More than " + str(highly_var_limit * 100) + "% of genes have been filtered out due to high variability!")

    #Remove highly variable genes
    adata = adata[:, adata.var.highly_variable==False]

    """### K-Nearest Neighbors
    Calculate the distance between each cell using the KNN algorithm. Distances will be used to cluster the cells in the next step.
    Note: warning just means it will proceed to automatically calculate PCA since it was not done beforehand.
    
    DEPRECATED: using k=15 for computational purposes. Also, it doesn't have too much of an impact in the end.
    Default (n=sqrt(adata.n_obs)): setting n as the square root of the length of the data is the general consensus if n is not provided.
    -Sources:
    https://towardsdatascience.com/how-to-find-the-optimal-value-of-k-in-knn-35d936e554eb
    https://discuss.analyticsvidhya.com/t/how-to-choose-the-value-of-k-in-knn-algorithm/2606/7
    https://stackoverflow.com/questions/11568897/value-of-k-in-k-nearest-neighbor-algorithm
    """
    print("*Do not be concerned about the following warning. Clustering data...")
    sc.pp.neighbors(adata, n_neighbors=n)
    log("KNN distances calculated using n="+str(n))

    """Cluster
    Cluster/Group each cell based on the distances calculated in the previous step using the Leiden algorithm.
    'resolution' determines the amount of clusters that will be formed (default: 0.5. The higher the resolution, the more clusters in the result)
    """
    sc.tl.leiden(adata, resolution=cluster_res)
    log("Clustering finished")

    #Visualize Cluster Results
    #Prepares the data to be visualized by simplifying multiple dimensions down to two dimensional coordinates using the UMAP algorithm.
    #This algoithm also uses the distances calculated in 'neighbors()'.
    #We will later label these clusters with cell types using marker gene identification.
    if tsne:
        sc.tl.tsne(adata)
        log("Calculated t-SNE")
        sc.pl.tsne(adata, color=['leiden'], title="cluster_res="+str(cluster_res), show=False)
    else: #UMAP
        sc.tl.umap(adata)
        log("Calculated UMAP")
        sc.pl.umap(adata, color=['leiden'], title="cluster_res="+str(cluster_res), show=False)
    save_figure("cluster.png", image_directory)

    #V&V
    if not '1' in adata.obs['leiden'].to_list():
        print("WARNING: Only one cluster was created! Please increase the cluster resolution!")

    #Repeat the previous steps and allow user to adjust cluster resolution until satisifed.
    res_i = 1
    while interrupt or not ('1' in adata.obs['leiden'].to_list()):
        try:
            prompt = input("Enter a decimal to change the cluster resolution (current: "+str(cluster_res)+") or leave blank to keep the results: ")
            if prompt == "":
                if not '1' in adata.obs['leiden'].to_list():
                    print("WARNING: Only one cluster was created! Please increase the cluster resolution!")
                else:
                    break
            cluster_res = float(prompt)
            sc.tl.leiden(adata, resolution=cluster_res)
            plot(adata, ['leiden'], "cluster_res="+str(cluster_res))
            save_figure("cluster_("+str(res_i)+").png", image_directory)
            res_i += 1

        except:
            if not prompt == "":    #Not a crash due to mono-cluster warning
                print("You must enter a decimal value!")

    print("Using cluster resolution of: "+str(cluster_res))
    log("Using cluster resolution of "+str(cluster_res))

    """Visualized data based on selected gene(s)
    Color cells based on their expression of a specific gene. 
    The first 2 genes will be displayed as a sample if argument not provided, then prompt user to choose which gene(s) to visualize until satisfied.
    Users can also view a list of genes by a handful at a time so it doesn't overload the command output.
    Users a exit this prompt at anytime to proceed to the next steps.
    Note: purple = no expression
    """
    #Initial display (argument passed genes or sample first 2 genes)
    view_genes = []
    if len(genes) != 0:    #Display selected genes' expression
        for gene in genes:
            if gene in adata.var_names:
                view_genes.append(gene)
            else:
                print("\'"+gene+"\' gene is not in the dataset.")
        plot(adata, view_genes)
    else:                   #Display the first 2 gene as a sample
        view_genes = []
        title = []
        i = 2
        for gene in adata.var_names:
            view_genes.append(gene)
            title.append("Sample: "+gene)
            i -= 1
            if i == 0: break
        plot(adata, view_genes, title)
    save_figure("gene_expression_plot.png", image_directory)

    #Additional gene visualization
    PAGE_ROWS = 6
    PAGE_COLS = 4
    gene_i = 1
    gene_list = adata.var_names.sort_values()
    while interrupt:
        prompt = input("Enter the gene(s) you wish to visualize separated by commas (,). Enter \"-list page_#\" to view a list of genes or \"-exit\" to proceed with the program: ")
        if "-exit" == prompt[0:5] or prompt == "":
            break
        elif "-list" == prompt[0:5]:
            try: page_num = int(prompt[6:])
            except: page_num = 0

            page = page_num*PAGE_ROWS*PAGE_COLS
            content = ""
            newline = 0
            for i in range(PAGE_ROWS*PAGE_COLS):
                try:
                    content += gene_list[page+i]+",\t"
                    newline+=1
                    if newline == PAGE_COLS:
                      content=content[:-2]+"\n"
                      newline = 0
                except IndexError:
                    break
            print("Enter '-list #' to view other pages on the list.\n"+content)
        else:
            prompted_genes = "".join(prompt.split()).split(",")
            view_genes = []
            for gene in prompted_genes:
                if gene in adata.var_names:
                    view_genes.append(gene)
                else:
                    print("\'"+gene+"\' gene is not in the dataset.")
            plot(adata, view_genes)
            save_figure("gene_expression_plot_(" + str(gene_i) + ").png", image_directory)
            gene_i += 1

    """Export adata to use in annotate.py"""
    adata.write(adata_dir+"run"+str(run_num)+"_"+output_name+"_adata.h5ad")
    VV_file_save(adata_dir, "run"+str(run_num)+"_"+output_name+"_adata.h5ad", "Successfully exported adata")
    print("\n*Exported data to \'run"+str(run_num)+"_adata.h5ad\'. The following steps can be repeated using \'annotate.py\' and this program can safely exited.*")
    if not os.path.isfile(annotate_py_dir+"annotate.py"):
        print("WARNING: \"annotate.py\" is missing from the environment! Please reinstall the package to prevent any more missing files!")

    """Annotate data
    Use ScoreCT to annotate data. Marker gene file must be provided for the package to work.
    If file not provided to this program, search using Cell Marker. 
    Only Human or Mouse are available in the Cell Marker database and tissue name is required.
    Using 'adata' and the marker gene file, annotate data and add results onto 'adata.obs', then visualize
    results as a UMAP graph. Finally, output adata.obs as a excel to externally view cell data stats and
    classification.
    
    Marker gene file format example (csv):
    Cell, Cell, Cell
    gene, gene, gene
    gene, gene, gene
    gene,     , gene
    etc.,      ,
    
    The program will automatically transpose the data if the file is in an incorrect format.
    """
    #Load marker file

    #Allow users to use own marker gene file
    marker_loaded = False
    retried = False
    if not markers_path == "":
        try:
            # Check if direct path or in marker directory
            if os.path.isfile(marker_dir + markers_path):
                markers_path = marker_dir + markers_path
            else:
                assert os.path.isfile(markers_path), "Could not find file. Please place marker gene files in "+marker_dir+"."

            ref_marker = ct.read_markers_from_file(markers_path)

            # V&V. Transpose and retry if fail.
            if not VV_markers(ref_marker):  # Retry loading file after transposing
                # Transpose data
                df = pd.read_csv(markers_path, header=None)
                df = df.T
                markers_path = markers_path[:-4] + "_corrected.csv"

                # Remove first numerical column
                new_header = df.iloc[0]
                df = df[1:]
                df.columns = new_header
                df.to_csv(markers_path, header=True)

                retried = True
                ref_marker = ct.read_markers_from_file(
                    markers_path)  # Only with this can we properly check if the data is formated correctly
                assert not ref_marker.empty, "Failed to load marker gene file: " + markers_path

                # Upon Success
                print(
                    "Marker gene file was in an incorrect format and has been transposed to \"" + markers_path + "\".")
                log("Marker gene file was in an incorrect format and has been transposed to \"" + markers_path + "\".")
            print("Using marker file: \"" + markers_path + "\"")
            log("Loaded marker gene file \"" + markers_path + "\"")
            marker_loaded = True
        except:
            if retried:
                os.remove(markers_path)  # For discretion if failed, otherwise allow user to keep
                traceback.print_exc()
                print(
                    "There is an issue with the file format. Correct the file or continue to use provided marker gene data (Human and Mouse only).")
                log("There is an issue with the file format")
            else:
                print(
                    "Failed to load marker gene file. Try again or continue to use provided marker gene data (Human and Mouse only).")
                log("Failed to load marker gene file")

    #Otherwise use default marker data
    if not marker_loaded:
        print("Retrieving information from Cell Marker. Note only Human and Mouse data are available!\n"
              "If your species is neither of those, please try again and provide a marker gene file in \'annotate.py\'.")
        # Prompt for species argument
        while species == "":
            species_prompt = input("Input species of the dataset: ")
            if not species_prompt == "":
                species = species_prompt

        species = species[0].upper() + species[1:].lower()
        #Change keyword to match format if applies
        if species == "Homo sapien" or species == "Homo sapiens":
            species = "Human"
        elif species == "Mus musculus":
            species = "Mouse"

        #V&V: Assert if species not available
        assert species == "Mouse" or species == "Human", "Could not find information for "+species+". Please provide a marker gene file for that species in \"annotate.py\"."

        # Prompt for tissue argument
        while tissue == "tissue" or tissue == "":
            tissue_prompt = input("Input tissue of the dataset: ")
            if not tissue_prompt == "":
                tissue = tissue_prompt
        tissue = tissue[0].upper() + tissue[1:].lower()

        #Retrieve data from Cell Marker
        print("Retrieving marker gene data...")
        ref_marker = ct.get_markers_from_db(species, tissue)
        print("Using species="+species+" and tissue="+tissue)
        log("Using Cell Marker with species="+species+" tissue="+tissue+" for marker gene reference")
        marker_loaded = True

        #V&V: Assert if empty (due to tissue)
        #if species == "Human" or species == "Mouse":
        assert not ref_marker.empty, "Could not find information on "+tissue+" for "+species+". Please try again using a different keyword for \'tissue\' on \"annotate.py\"."

    #Calculate statistics
    sc.tl.rank_genes_groups(adata, 'leiden', method='t-test')
    log("Ranked gene groups")

    marker_df = ct.wrangle_ranks_from_anndata(adata)
    log("Wraggled ranks form adata")

    #Calculate p-value and scores needed for 'assign_celltypes'
    background = adata.var.index.tolist()
    ct_pval, ct_score = ct.celltype_scores(nb_bins=m,
                                            ranked_genes=marker_df,
                                            K_top = K,
                                            marker_ref=ref_marker,
                                            background_genes=background)
    log("Calculated cell type scores")

    #Annotate
    adata.obs['cell_type'] = ct.assign_celltypes(cluster_assignment=adata.obs['leiden'], ct_pval_df=ct_pval, ct_score_df=ct_score)
    VnV_classification()

    #Visualize results
    plot_annotation(adata, ['cell_type'], ['Cell Type Annotation for '+species+" "+tissue])
    save_figure("annotation_plot.png", dir=final_plot_dir)

    # Repeated prompt for K, m, and cluster_res; recalculate annotation, and display results until user is satisfied.
    if interrupt:
        print("*Take this opportunity to experiment with different parameters regarding just the annotation process.*"
              "*If you would like to do this later, please use 'annotate.py' and with the post-filtered 'adata.h5ad' file.*")
    ann_i = 1
    while interrupt or not ('1' in adata.obs['leiden'].to_list()):
        # Prompt for cluster resolution
        while interrupt or not ('1' in adata.obs['leiden'].to_list()):
            try:
                prompt = input("Enter a decimal to change the cluster resolution (current: " + str(cluster_res) + ") or leave blank to keep the results: ")
                if prompt == "":
                    if not '1' in adata.obs['leiden'].to_list():
                        print("WARNING: Only one cluster was created! Please increase the cluster resolution!")
                    else:
                        break
                cluster_res = float(prompt)
                sc.tl.leiden(adata, resolution=cluster_res)
                plot(adata, ['leiden'], "cluster_res="+str(cluster_res))
                save_figure("cluster_(" + str(res_i) + ").png", image_directory)
                res_i += 1
            except:
                if not prompt == "":  # Not a crash due to mono-cluster warning
                    print("You must enter a decimal value!")
        print("Using cluster resolution of: " + str(cluster_res))

        # Calculate statistics
        sc.tl.rank_genes_groups(adata, 'leiden', method='t-test')
        log("Ranked gene groups")

        marker_df = ct.wrangle_ranks_from_anndata(adata)
        log("Wraggled ranks form adata")

        background = adata.var.index.tolist()

        # Repeat the previous steps and allow user to adjust K and m until satisifed.
        while interrupt:
            try:
                prompt = input("Enter a value for the top K genes to include in scoring (current: " + str(K) + ") or leave blank to keep the value." +
                               "\nOr enter \"cluster\" to re-adjust cluster resolution or \"exit\" to exit: ")
                if prompt == "cluster" or prompt == "exit":
                    break
                elif not prompt == "":
                    K = int(prompt)

                prompt = input("Enter a value for the m number of bins to use to divide the gene ranking (current: " + str(m) + ") or leave blank to keep the value: ")
                if not prompt == "": m = int(prompt)

                ct_pval, ct_score = ct.celltype_scores(nb_bins=m,
                                                       ranked_genes=marker_df,
                                                       K_top=K,
                                                       marker_ref=ref_marker,
                                                       background_genes=background)
                adata.obs['cell_type'] = ct.assign_celltypes(cluster_assignment=adata.obs['leiden'], ct_pval_df=ct_pval, ct_score_df=ct_score)
                VnV_classification()
                plot_annotation(adata, ['cell_type'], "K="+str(K)+", m="+str(m)+", cluster_res="+str(cluster_res))
                save_figure("annotation_plot_(" + str(ann_i) + ").png", final_plot_dir)
                ann_i += 1
            except:
                print("\nYou must enter integer values!")
        if (not interrupt) or prompt == "exit": break

    #Export results as an excel
    adata.obs = adata.obs.rename(columns={"leiden":"cluster"})  #Rename to avoid confusion
    ann_output_name = "run"+str(run_num)+"_"+output_name+"_annotation.xlsx"
    adata.obs.to_excel(annotation_dir+ann_output_name)
    VV_file_save(annotation_dir, ann_output_name, "Exported \""+ann_output_name+"\"")

    #Log final parameters if on interrupt run
    if interrupt:
        log("\n***Final Parameters***\n"
            "file path: "+file_path+"\n"
            "marker gene file: "+markers_path+"\n"
            "species: "+species+"\n"
            "tissue: "+tissue+"\n"
            "min genes: "+str(min_genes)+"\n"
            "min cells: "+str(min_cells)+"\n"
            "knn k: "+str(n)+"\n"
            "cluster resolution: "+str(cluster_res)+"\n"
            "scorect K: "+str(K)+"\n"
            "scorect m: "+str(m)+"\n"
            "plot: "+plot_log+"\n"      #Cannot be changed, no need to parse again
            "display genes: "+str(genes)+"\n"
            "interrupt: "+str(interrupt)+"\n"
            "***********************")

    #Message about other python script
    print("*Annotation exported to \'"+ann_output_name+'annotation.xlsx\'*')
    log("*Program finished running without any errors*")
except Exception:
    traceback.print_exc()
    traceback.print_exc(file=file)
finally:
    file.close()